#version 440 core

uniform sampler2D color;
uniform sampler2D pos;
uniform sampler2D norm;
uniform sampler2D shadowsum;
uniform uint num_lights;
uniform uint ntriangles;
uniform mat4 sm;
uniform mat4 cm;

uniform vec3 mmv;

out vec4 ocolor;

struct LightPoint
{
vec3 position;
vec3 color;
};




uniform LightPoint light[100];

mat4 bias = mat4(
0.5, 0.0, 0.0, 0.0,
0.0, 0.5, 0.0, 0.0,
0.0, 0.0, 0.5, 0.0,
0.5, 0.5, 0.5, 1.0
);

uniform vec3 diffuse_albedo = vec3(0.5, 0.2, 0.7);
uniform vec3 specular_albedo = vec3(0.7);
uniform float specular_power = 128.0;





void main()
{
vec2 screenSize = vec2(1280,720);
vec4 wpos = texture2D(pos, gl_FragCoord.xy / screenSize);
vec4 n = texture2D(norm, gl_FragCoord.xy / screenSize);
vec4 col;
col = texture2D(color, gl_FragCoord.xy / screenSize);

vec4 shadowcoord = bias * cm * sm * wpos;
vec3 cp = vec3(0,20,0);

vec3 difsum = vec3(0,0,0);
vec3 spesum = difsum;
vec3 ambient_color = vec3(0.1, 0.1, 0.1);
for(uint i = 0; i < num_lights; i++)
{
vec3 ed = wpos.xyz - mmv;
vec3 cd = wpos.xyz - cp;
vec3 L = wpos.xyz - light[i].position;
float dist = length(L);
L = normalize(L);
vec3 N = normalize(n.xyz);
vec3 R = reflect(-L, N);
float NdotR = abs(dot(normalize(ed), R));
float NdotL =abs(dot(N, L));
float attenuation = 500.0 / (pow(dist, 2.0) + 1.0);

vec3 diffuse_color = light[i].color * col.rgb *
NdotL * attenuation;
vec3 specular_color = light[i].color *
pow(NdotR, specular_power)
* attenuation;

difsum += diffuse_color;
spesum += specular_color;
}

//float bia = 0.005*tan(acos(NdotL)); // cosTheta is dot( n,l ), clamped between 0 and 1
//bia = clamp(bia, 0,0.01);

float shadow = texture2D(shadowsum, gl_FragCoord.xy / screenSize).r;
//vec2 shadc = vec2(shadowcoord.x / shadowcoord.w, shadowcoord.y / shadowcoord.w);
//if(shadowcoord.w > 0.0)
//if((texture(shadowmap, wpos.xyz - light[0].position).r * 1000) < length(wpos.xyz - light[0].position))
//shadow = 0.2;


ocolor = vec4(ambient_color + (difsum + spesum) * shadow,1);

}
